import fs from 'fs-extra'
import { buildCodeFromRules } from './openai'
import { join } from 'path'

const templates = [
  {
    path: 'src/infrastructure/components/layout/Container.tsx',
    code: "import type { Props } from '@domain/entities/Component'; import { center, classNames, padding } from '../utils'; export const Container = ({ id, className, breakpoint, center: isCentered, padding: paddingSize, children, ['data-component']: dataComponent = 'Container', }: Props['Container']) => { const classes = []; if (breakpoint === 'none') classes.push('w-full'); else if (breakpoint) classes.push(breakpoint + ':container'); else classes.push('container'); if (isCentered === true) classes.push(center({ breakpoint, dimension: 'x' })); if (paddingSize) classes.push(padding({ size: paddingSize, dimension: 'x', breakpoint })); return (<div id={id} className={classNames(...classes, className)} data-component={dataComponent}>{children}</div>); }",
  },
  {
    path: 'src/domain/entities/Component/layout/Container.tsx',
    code: "import type { ReactComponent, Base, BaseProps, Breakpoint, Padding } from '../base/base'; import type { Component } from '..'; import type { State } from '@domain/entities/Page/State'; export interface Props extends BaseProps { children: React.ReactNode; center?: boolean; breakpoint?: Breakpoint; padding?: Padding; } interface Params extends Omit<Props, 'children'> { children: Component[]; Component: ReactComponent<Props>; } export class Container implements Base<Props> { constructor(private params: Params) {} init = async () => { const { children } = this.params; await Promise.all(children.map((child) => child.init())); }; render = async (state: State) => { const { Component, ...defaultProps } = this.params; const children = await Promise.all(this.params.children.map((child) => child.render(state))); return (props?: Partial<Props>) => (<Component {...{ ...defaultProps, children: children.map((Child, index) => <Child key={index} />), ...props, }} />); }; validateConfig = () => { return []; }; }",
  },
  {
    path: 'src/adapter/api/configs/Component/layout/Container.ts',
    code: "import type { Breakpoint, Padding } from '@domain/entities/Component/base/base'; import type { Component } from '..'; import type { Base } from '../base/Base'; export interface Config extends Base { children: Component[]; center?: boolean; breakpoint?: Breakpoint; padding?: Padding; } export interface Container extends Config { component: 'Container'; }",
  },
  {
    path: 'src/adapter/api/mappers/ComponentMapper/layout/ContainerMapper.ts',
    code: "import { Container } from '@domain/entities/Component/layout/Container'; import type { Config } from '@adapter/api/configs/Component/layout/Container'; import { ComponentMapper, type Services } from '@adapter/api/mappers/ComponentMapper'; export class ContainerMapper { static toEntity = (config: Config, services: Services): Container => { const { components } = services; const children = ComponentMapper.toManyEntities(config.children, services); return new Container({ ...config, children, Component: components.Container }); }; }",
  },
  {
    path: 'tests/components/layout/container.test.ts',
    code: "import { test, expect } from '@tests/fixtures'; import App, { type App as Config } from '@safidea/engine'; test.describe('Container', () => { test('should render a container', async ({ page }) => { const config: Config = { name: 'App', pages: [{ name: 'Page', path: '/', body: [{ component: 'Container', children: [{ component: 'Paragraph', text: 'Hello world' }] }] }] }; const app = new App(); const url = await app.start(config); await page.goto(url); const container = page.getByText('Hello world'); await expect(container).toBeVisible(); }); test('should render a container in app page', async ({ page }) => { const config: Config = { name: 'App', pages: [{ name: 'Page', path: '/', body: [{ component: 'Container', children: [{ component: 'Paragraph', text: 'Hello world' }] }] }] }; const app = new App(); const url = await app.start(config); await page.goto(url); const container = page.getByText('Hello world'); await expect(container).toBeVisible(); }); test('should render the container id', async ({ page }) => { const config: Config = { name: 'App', pages: [{ name: 'Page', path: '/', body: [{ component: 'Container', children: [{ component: 'Paragraph', text: 'Hello world', id: 'my-paragraph' }] }] }] }; const app = new App(); const url = await app.start(config); await page.goto(url); const container = page.getByText('Hello world'); await expect(container).toHaveAttribute('id'); expect(await container.getAttribute('id')).toBe('my-paragraph'); }); test.describe('Breakpoint', () => { test('should render a container with default breakpoint', async ({ page }) => { const config: Config = { name: 'Container', pages: [{ name: 'Page', path: '/', body: [{ component: 'Container', children: [] }] }] }; const app = new App(); const url = await app.start(config); await page.setViewportSize({ width: 1800, height: 1200 }); await page.goto(url); const style = await page.evaluate((selector) => getComputedStyle(document.querySelector(selector)!), 'div[data-component=\"Container\"]'); expect(style.width).toBe('1536px'); expect(style.maxWidth).toBe('1536px'); }); test('should render a container with no breakpoint', async ({ page }) => { const config: Config = { name: 'Container', pages: [{ name: 'Page', path: '/', body: [{ component: 'Container', breakpoint: 'none', children: [] }] }] }; const app = new App(); const url = await app.start(config); await page.setViewportSize({ width: 1800, height: 1200 }); await page.goto(url); const style = await page.evaluate((selector) => getComputedStyle(document.querySelector(selector)!), 'div[data-component=\"Container\"]'); expect(style.width).toBe('1800px'); expect(style.maxWidth).toBe('none'); }); test('should render a container with a small breakpoint', async ({ page }) => { const config: Config = { name: 'Container', pages: [{ name: 'Page', path: '/', body: [{ component: 'Container', breakpoint: 'sm', children: [] }] }] }; const app = new App(); const url = await app.start(config); await page.setViewportSize({ width: 700, height: 500 }); await page.goto(url); const style = await page.evaluate((selector) => getComputedStyle(document.querySelector(selector)!), 'div[data-component=\"Container\"]'); expect(style.width).toBe('640px'); expect(style.maxWidth).toBe('640px'); }); test('should render a container with a medium breakpoint', async ({ page }) => { const config: Config = { name: 'Container', pages: [{ name: 'Page', path: '/', body: [{ component: 'Container', breakpoint: 'md', children: [] }] }] }; const app = new App(); const url = await app.start(config); await page.setViewportSize({ width: 800, height: 500 }); await page.goto(url); const style = await page.evaluate((selector) => getComputedStyle(document.querySelector(selector)!), 'div[data-component=\"Container\"]'); expect(style.width).toBe('768px'); expect(style.maxWidth).toBe('768px'); }); test('should render a container with a large breakpoint', async ({ page }) => { const config: Config = { name: 'Container', pages: [{ name: 'Page', path: '/', body: [{ component: 'Container', breakpoint: 'lg', children: [] }] }] }; const app = new App(); const url = await app.start(config); await page.setViewportSize({ width: 1200, height: 500 }); await page.goto(url); const style = await page.evaluate((selector) => getComputedStyle(document.querySelector(selector)!), 'div[data-component=\"Container\"]'); expect(style.width).toBe('1024px'); expect(style.maxWidth).toBe('1024px'); }); test('should render a container with an extra large breakpoint', async ({ page }) => { const config: Config = { name: 'Container', pages: [{ name: 'Page', path: '/', body: [{ component: 'Container', breakpoint: 'xl', children: [] }] }] }; const app = new App(); const url = await app.start(config); await page.setViewportSize({ width: 1400, height: 900 }); await page.goto(url); const style = await page.evaluate((selector) => getComputedStyle(document.querySelector(selector)!), 'div[data-component=\"Container\"]'); expect(style.width).toBe('1280px'); expect(style.maxWidth).toBe('1280px'); }); test('should render a container with a 2 extra large breakpoint', async ({ page }) => { const config: Config = { name: 'Container', pages: [{ name: 'Page', path: '/', body: [{ component: 'Container', breakpoint: '2xl', children: [] }] }] }; const app = new App(); const url = await app.start(config); await page.setViewportSize({ width: 1800, height: 1200 }); await page.goto(url); const style = await page.evaluate((selector) => getComputedStyle(document.querySelector(selector)!), 'div[data-component=\"Container\"]'); expect(style.width).toBe('1536px'); expect(style.maxWidth).toBe('1536px'); }); }); test.describe('Center', () => { test('should render a non centered container', async ({ page }) => { const config: Config = { name: 'Container', pages: [{ name: 'Page', path: '/', body: [{ component: 'Container', children: [] }] }] }; const app = new App(); const url = await app.start(config); await page.setViewportSize({ width: 1800, height: 1200 }); await page.goto(url); const style = await page.evaluate((selector) => getComputedStyle(document.querySelector(selector)!), 'div[data-component=\"Container\"]'); expect(style.marginLeft).toBe('0px'); expect(style.marginRight).toBe('0px'); }); test('should render a centered container', async ({ page }) => { const config: Config = { name: 'Container', pages: [{ name: 'Page', path: '/', body: [{ component: 'Container', center: true, children: [] }] }] }; const app = new App(); const url = await app.start(config); await page.setViewportSize({ width: 1800, height: 1200 }); await page.goto(url); const style = await page.evaluate((selector) => getComputedStyle(document.querySelector(selector)!), 'div[data-component=\"Container\"]'); expect(style.marginLeft).toBe('132px'); expect(style.marginRight).toBe('132px'); }); test('should render a container with a small breakpoint', async ({ page }) => { const config: Config = { name: 'Container', pages: [{ name: 'Page', path: '/', body: [{ component: 'Container', center: true, breakpoint: 'sm', children: [] }] }] }; const app = new App(); const url = await app.start(config); await page.setViewportSize({ width: 700, height: 500 }); await page.goto(url); const style = await page.evaluate((selector) => getComputedStyle(document.querySelector(selector)!), 'div[data-component=\"Container\"]'); expect(style.marginLeft).toBe('30px'); expect(style.marginRight).toBe('30px'); }); test('should render a container with a medium breakpoint', async ({ page }) => { const config: Config = { name: 'Container', pages: [{ name: 'Page', path: '/', body: [{ component: 'Container', center: true, breakpoint: 'md', children: [] }] }] }; const app = new App(); const url = await app.start(config); await page.setViewportSize({ width: 800, height: 500 }); await page.goto(url); const style = await page.evaluate((selector) => getComputedStyle(document.querySelector(selector)!), 'div[data-component=\"Container\"]'); expect(style.marginLeft).toBe('16px'); expect(style.marginRight).toBe('16px'); }); test('should render a container with a large breakpoint', async ({ page }) => { const config: Config = { name: 'Container', pages: [{ name: 'Page', path: '/', body: [{ component: 'Container', center: true, breakpoint: 'lg', children: [] }] }] }; const app = new App(); const url = await app.start(config); await page.setViewportSize({ width: 1200, height: 500 }); await page.goto(url); const style = await page.evaluate((selector) => getComputedStyle(document.querySelector(selector)!), 'div[data-component=\"Container\"]'); expect(style.marginLeft).toBe('88px'); expect(style.marginRight).toBe('88px'); }); test('should render a container with an extra large breakpoint', async ({ page }) => { const config: Config = { name: 'Container', pages: [{ name: 'Page', path: '/', body: [{ component: 'Container', center: true, breakpoint: 'xl', children: [] }] }] }; const app = new App(); const url = await app.start(config); await page.setViewportSize({ width: 1400, height: 900 }); await page.goto(url); const style = await page.evaluate((selector) => getComputedStyle(document.querySelector(selector)!), 'div[data-component=\"Container\"]'); expect(style.marginLeft).toBe('60px'); expect(style.marginRight).toBe('60px'); }); test('should render a container with a 2 extra large breakpoint', async ({ page }) => { const config: Config = { name: 'Container', pages: [{ name: 'Page', path: '/', body: [{ component: 'Container', center: true, breakpoint: '2xl', children: [] }] }] }; const app = new App(); const url = await app.start(config); await page.setViewportSize({ width: 1800, height: 1200 }); await page.goto(url); const style = await page.evaluate((selector) => getComputedStyle(document.querySelector(selector)!), 'div[data-component=\"Container\"]'); expect(style.marginLeft).toBe('132px'); expect(style.marginRight).toBe('132px'); }); }); test.describe('Padding', () => { test('should render a container without horizontal padding', async ({ page }) => { const config: Config = { name: 'Container', pages: [{ name: 'Page', path: '/', body: [{ component: 'Container', children: [] }] }] }; const app = new App(); const url = await app.start(config); await page.goto(url); const style = await page.evaluate((selector) => getComputedStyle(document.querySelector(selector)!), 'div[data-component=\"Container\"]'); expect(style.paddingLeft).toBe('0px'); expect(style.paddingRight).toBe('0px'); }); test('should render a container with horizontal padding of 4', async ({ page }) => { const config: Config = { name: 'Container', pages: [{ name: 'Page', path: '/', body: [{ component: 'Container', padding: '4', children: [] }] }] }; const app = new App(); const url = await app.start(config); await page.goto(url); const style = await page.evaluate((selector) => getComputedStyle(document.querySelector(selector)!), 'div[data-component=\"Container\"]'); expect(style.paddingLeft).toBe('16px'); expect(style.paddingRight).toBe('16px'); }); test('should render a container with horizontal padding of 20', async ({ page }) => { const config: Config = { name: 'Container', pages: [{ name: 'Page', path: '/', body: [{ component: 'Container', padding: '20', children: [] }] }] }; const app = new App(); const url = await app.start(config); await page.goto(url); const style = await page.evaluate((selector) => getComputedStyle(document.querySelector(selector)!), 'div[data-component=\"Container\"]'); expect(style.paddingLeft).toBe('80px'); expect(style.paddingRight).toBe('80px'); }); }); });",
  },
]

async function createFilesFromComponent(name: string) {
  const guidelines = [
    'You have to create an new file based on the template provided and the component provided',
    'The code of the file should be in the code property in the JSON response',
    'You should return the path of the file created at the path property in the JSON response',
    'The path should also be updated with the component name',
  ]
  const componentPath = `src/infrastructure/components/__imports__/${name}.tsx`
  console.log(`Reading component from ${componentPath}`)
  const componentCode = await fs.readFile(join(process.cwd(), componentPath), 'utf-8')
  for (const template of templates) {
    console.log(`Building ${name} based on ${template.path}`)
    const userPrompt = `Build a "${name}" file based on this template: ${JSON.stringify(template, null, 2)} and this "${name}" component: ${componentCode}`
    const { code, path } = await buildCodeFromRules(guidelines, userPrompt)
    console.log(`Writing ${path}`)
    await fs.ensureFile(join(process.cwd(), path))
    await fs.writeFile(join(process.cwd(), path), code)
  }
}

createFilesFromComponent('accordion')
